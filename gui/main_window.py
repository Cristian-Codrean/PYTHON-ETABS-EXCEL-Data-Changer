import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import sys
import os
import json
import sqlite3
from datetime import datetime

# ==================== IMPORTURI FIXATE ====================
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.insert(0, parent_dir)

# √éncercƒÉ sƒÉ importe API-ul ETABS
try:
    import etabs_api.operations

    print("API ETABS importat cu succes")
except ImportError as e:
    print(f"Avertisment import API ETABS: {e}")


    # Fallback pentru testare
    class MockOperations:
        @staticmethod
        def get_story_names():
            return ["B1", "P1", "P2", "P3", "P4", "P5"]

        @staticmethod
        def get_comb_names():
            return [f"Combo{i}" for i in range(1, 21)]

        @staticmethod
        def get_selected_frames_live():
            import random
            frames = ["Frame1", "Frame2", "Frame3", "Frame4", "Frame5"]
            return random.sample(frames, random.randint(1, 3))

        @staticmethod
        def clear_frame_selection():
            return True

        @staticmethod
        def hide_specific_frames(frame_list):
            print(f"Mock: Ascund frame-uri {frame_list}")
            return True

        @staticmethod
        def show_all_frames():
            return True

        @staticmethod
        def get_label_and_story(name):
            return [f"Label-{name}", "Story1"]

        @staticmethod
        def get_frame_guid(name):
            return f"mock-guid-{name}"

        @staticmethod
        def get_section_name(name):
            return "MockSection"


    etabs_api.operations = MockOperations()

# ImportƒÉ widget-uri
try:
    from .widgets import ScenarioFrame, FileSelectionFrame, ControlButtons, SelectionConfirmationDialog, \
        SimpleSummaryPopup
except ImportError:
    try:
        from widgets import ScenarioFrame, FileSelectionFrame, ControlButtons, SelectionConfirmationDialog, \
            SimpleSummaryPopup
    except ImportError:
        try:
            sys.path.insert(0, current_dir)
            from widgets import ScenarioFrame, FileSelectionFrame, ControlButtons, SelectionConfirmationDialog, \
                SimpleSummaryPopup
        except ImportError as e:
            print(f"E»ôuat import widget-uri: {e}")
            sys.exit(1)

# ImportƒÉ opera»õiuni Excel direct
try:
    from excel.operations import copy_excel_file
except ImportError:
    def copy_excel_file(template_path, output_path):
        print(f"Mock: Ar crea Excel din {template_path} √Æn {output_path}")
        return True

# ImportƒÉ opera»õiuni bazƒÉ de date direct
try:
    from db.operations import create_database
except ImportError:
    def create_database(frame_list):
        print(f"Mock: Ar crea baza de date cu {len(frame_list)} frame-uri")
        return True


class DesignApp:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Design Comparison Tool")
        self.root.resizable(True, True)

        # TesteazƒÉ conexiunea ETABS fƒÉc√¢nd un apel API simplu
        print("üîó Testare conexiune ETABS...")
        try:
            # For»õeazƒÉ conexiunea prin apelarea unei func»õii simple
            from etabs_api.connection import get_sap_model
            sap_model = get_sap_model()

            # TesteazƒÉ conexiunea cu un apel simplu
            test_result = sap_model.GetModelFilename()
            print(f"‚úÖ Conexiune ETABS SUCCES. Model: {test_result}")

        except Exception as e:
            print(f"‚ùå Test conexiune ETABS e»ôuat: {e}")
            print("üí° Te rog asigurƒÉ-te cƒÉ ETABS ruleazƒÉ cu un model deschis.")
            self.root.destroy()
            return

        # DacƒÉ ajungem aici, conexiunea este bunƒÉ - ini»õializeazƒÉ GUI
        self.initialize_gui()

    def initialize_gui(self):
        """Ini»õializeazƒÉ componentele GUI"""
        print("Ini»õializare GUI...")

        # ==================== URƒÇRIRE STARE ====================
        # Starea butoanelor pentru ambele scenarii
        self.button_states = {
            ("A", "DCL"): False, ("A", "DCM"): False, ("A", "DCH"): False,
            ("A", "Secundare"): False, ("A", "Dir X"): False, ("A", "Dir Y"): False,
            ("B", "DCL"): False, ("B", "DCM"): False, ("B", "DCH"): False,
            ("B", "Secundare"): False, ("B", "Dir X"): False, ("B", "Dir Y"): False,
        }

        # Starea radio butoanelor de sus
        self.top_radio_state = "Normale"

        # Combina»õiile selectate
        self.selected_combinations = {
            "A_upper": [], "A_lower": [], "B_upper": [], "B_lower": []
        }

        # Valoarea etajului selectat
        self.etaj_value = None

        # ==================== URƒÇRIRE SELEC»öIE GRINZI ====================
        self.beam_selection_active = False
        self.current_beam_group = []
        self.all_beam_groups_a = []  # Pentru InfrastructurƒÉ
        self.all_beam_groups_b = []  # Pentru SuprastructurƒÉ
        self.current_scenario = None
        self.tracking_id = None

        # ==================== CONTAINER PRINCIPAL ====================
        container = ttk.Frame(self.root)
        container.pack(expand=True, fill="both")

        # --- Switch top pentru rezisten»õe ---
        switches_frame = ttk.Frame(container)
        switches_frame.pack(pady=10)
        self.rezistente_var = tk.StringVar(value="Normale")
        switch1 = ttk.Frame(switches_frame)
        switch1.pack()
        tk.Radiobutton(switch1, text="Rezisten»õe Normale", variable=self.rezistente_var, value="Normale",
                       command=self.update_top_radio_state).pack(side="left", padx=20)
        tk.Radiobutton(switch1, text="Rezisten»õe Medii", variable=self.rezistente_var, value="Medii",
                       command=self.update_top_radio_state).pack(side="left", padx=20)

        # --- Dropdown etaj ---
        ttk.Label(container, text="Etaj:").pack()
        self.story_var = tk.StringVar()
        self.story_dropdown = ttk.Combobox(container, textvariable=self.story_var, state="readonly")

        # Umple dropdown cu etaje din ETABS
        try:
            stories = etabs_api.operations.get_story_names()
            self.story_dropdown['values'] = stories
            print(f"√éncƒÉrcat {len(stories)} etaje din ETABS")
        except Exception as e:
            print(f"Eroare la √ÆncƒÉrcarea etajelor: {e}")
            self.story_dropdown['values'] = []

        self.story_dropdown.pack(pady=5)
        self.story_dropdown.bind('<<ComboboxSelected>>', self.update_etaj_value)

        # --- Container frame-uri scenarii ---
        frame_scenarios = ttk.Frame(container)
        frame_scenarios.pack()

        # ==================== FRAME-URI SCENARII ====================
        # Scenariul A - Infrastructura
        self.scenario_a = ScenarioFrame(
            parent=frame_scenarios,
            scenario_name="Infrastructura",
            scenario_id="A",
            button_states=self.button_states,
            button_command=self.set_variant,
            clear_command=self.clear_scenario_a,
            action_command=lambda: self.start_beam_selection("A")
        )
        self.scenario_a.frame.grid(row=0, column=0, padx=20, pady=10, sticky="n")

        # Scenariul B - Suprastructura
        self.scenario_b = ScenarioFrame(
            parent=frame_scenarios,
            scenario_name="Suprastructura",
            scenario_id="B",
            button_states=self.button_states,
            button_command=self.set_variant,
            clear_command=self.clear_scenario_b,
            action_command=lambda: self.start_beam_selection("B")
        )
        self.scenario_b.frame.grid(row=0, column=1, padx=20, pady=10, sticky="n")

        # Umple listbox-uri cu combina»õii
        self.fill_listbox(self.scenario_a.list_upper)
        self.fill_listbox(self.scenario_a.list_lower)
        self.fill_listbox(self.scenario_b.list_upper)
        self.fill_listbox(self.scenario_b.list_lower)

        # ==================== BUTOANE CONTROL ====================
        self.control_buttons = ControlButtons(
            parent=container,
            check_command=self.check_selection,
            clear_command=self.unselect_all
        )
        self.control_buttons.pack(pady=5)

        # ==================== SELEC»öIE FI»òIERE ====================
        self.file_frame = FileSelectionFrame(
            parent=container,
            browse_default_command=self.browse_default_file,
            browse_result_command=self.browse_result_folder
        )
        self.file_frame.pack(pady=10, fill=tk.X, padx=20)

        # ==================== FRAME BUTOANE JOS ====================
        # CreeazƒÉ un frame pentru butoanele de jos sƒÉ fie aliniate
        bottom_frame = ttk.Frame(container)
        bottom_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=20, pady=20)

        # Butonul Create Excel √Æn st√¢nga
        ttk.Button(bottom_frame, text="Create Excel", command=self.create_excel, width=40).pack(
            side=tk.LEFT, ipadx=20, ipady=10
        )

        # Butonul Close √Æn dreapta
        ttk.Button(bottom_frame, text="Close", command=self.close_application, width=10).pack(
            side=tk.RIGHT, ipadx=10, ipady=5
        )

    def create_excel(self):
        """CreeazƒÉ baza de date localƒÉ, apoi copiazƒÉ Excel »ôi DB √Æn folderul specificat"""
        print("üéØ ApƒÉsat buton Create Excel")

        # VerificƒÉ folderul de rezultate
        result_folder = self.file_frame.result_folder_var.get()
        if not result_folder:
            messagebox.showerror("Eroare", "SelecteazƒÉ un folder de rezultate!")
            return

        # VerificƒÉ fi»ôierul template
        default_file = self.file_frame.default_file_var.get()
        if not default_file:
            messagebox.showerror("Eroare", "SelecteazƒÉ un fi»ôier template!")
            return

        try:
            # CreeazƒÉ nume de fi»ôier cu timestamp
            import datetime
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            excel_filename = f"beam_analysis_{timestamp}.xlsx"
            excel_path = os.path.join(result_folder, excel_filename)

            # CreeazƒÉ nume pentru baza de date cu acela»ôi timestamp
            db_filename = f"beam_database_{timestamp}.db"
            db_path = os.path.join(result_folder, db_filename)

            print(f"üìÅ √éncep procesul de creare Excel »ôi DB...")
            print(f"üìÑ Template Excel: {default_file}")
            print(f"üíæ Destina»õie Excel: {excel_path}")
            print(f"üóÉÔ∏è Destina»õie DB: {db_path}")

            # Pas 1: CreeazƒÉ baza de date LOCALƒÇ cu toate grinzile selectate
            print("üì¶ Creare bazƒÉ de date localƒÉ cu grinzile selectate...")
            all_beams = []
            for group in self.all_beam_groups_a:
                all_beams.extend(group)
            for group in self.all_beam_groups_b:
                all_beams.extend(group)

            if not all_beams:
                messagebox.showerror("Eroare", "Nu sunt grinzi selectate pentru a crea baza de date!")
                return

            # CreeazƒÉ baza de date localƒÉ
            success = create_database(all_beams)
            if not success:
                messagebox.showerror("Eroare", "Nu s-a putut crea baza de date localƒÉ!")
                return

            print("‚úÖ BazƒÉ de date localƒÉ creatƒÉ cu succes!")

            # Pas 2: Aici vor fi adƒÉugate func»õiile pentru popularea bazei de date
            # cu informa»õii suplimentare din ETABS
            print("üîß Populare baza de date cu informa»õii detaliate...")
            self.populate_database_with_details()

            # Pas 3: Aici vor fi adƒÉugate func»õiile pentru procesarea Excel
            # care vor folosi baza de date localƒÉ
            print("üìä Procesare fi»ôier Excel cu date din baza de date...")
            excel_success = self.process_excel_with_database(default_file, excel_path)

            if not excel_success:
                messagebox.showerror("Eroare", "Nu s-a putut procesa fi»ôierul Excel!")
                return

            # Pas 4: CopiazƒÉ baza de date LOCALƒÇ √Æn folderul de rezultate
            if os.path.exists("frames.db"):
                try:
                    import shutil
                    shutil.copy2("frames.db", db_path)
                    print(f"‚úÖ BazƒÉ de date copiatƒÉ √Æn: {db_path}")
                except Exception as e:
                    print(f"‚ö†Ô∏è Eroare la copierea bazei de date: {e}")
                    messagebox.showerror("Eroare", f"Eroare la copierea bazei de date: {e}")
                    return
            else:
                print("‚ùå Baza de date localƒÉ nu existƒÉ pentru copiere")
                messagebox.showerror("Eroare", "Baza de date localƒÉ nu a fost creatƒÉ!")
                return

            # Afi»ôeazƒÉ mesaj de succes
            print(f"‚úÖ Proces completat cu succes!")
            messagebox.showinfo("Succes",
                                f"Proces completat cu succes!\n\n"
                                f"Fi»ôier Excel creat:\n{excel_path}\n\n"
                                f"BazƒÉ de date creatƒÉ:\n{db_path}")

        except Exception as e:
            print(f"‚ùå Eroare la crearea Excel-ului: {e}")
            messagebox.showerror("Eroare", f"Eroare: {e}")

    def populate_database_with_details(self):
        """PopuleazƒÉ baza de date cu informa»õii detaliate din ETABS"""
        try:
            # ConecteazƒÉ-te la baza de date localƒÉ
            conn = sqlite3.connect("frames.db")
            cursor = conn.cursor()

            # Ob»õine toate grinzile din baza de date
            cursor.execute("SELECT UniqueName FROM Frames")
            beams = cursor.fetchall()

            print(f"üîç Populez detalii pentru {len(beams)} grinzi...")

            for (beam_name,) in beams:
                try:
                    # Ob»õine informa»õii detaliate din ETABS
                    label, story = etabs_api.operations.get_label_and_story(beam_name)
                    guid = etabs_api.operations.get_frame_guid(beam_name)
                    section_name = etabs_api.operations.get_section_name(beam_name)

                    # Ob»õine geometria
                    geometry = etabs_api.operations.get_geometry(beam_name)
                    length = geometry['length'] if geometry else 0

                    # ActualizeazƒÉ √Ænregistrarea √Æn baza de date
                    cursor.execute("""
                    UPDATE Frames 
                    SET Label = ?, Story = ?, GUID = ?, SectionName = ?, Length = ?
                    WHERE UniqueName = ?
                    """, (label, story, guid, section_name, length, beam_name))

                    print(f"‚úÖ Actualizat: {beam_name}")

                except Exception as e:
                    print(f"‚ö†Ô∏è Eroare la actualizarea grinzii {beam_name}: {e}")
                    continue

            # SalveazƒÉ schimbƒÉrile
            conn.commit()
            conn.close()
            print("‚úÖ Baza de date a fost populatƒÉ cu informa»õii detaliate!")

        except Exception as e:
            print(f"‚ùå Eroare la popularea bazei de date: {e}")

    def process_excel_with_database(self, template_path, output_path):
        """ProceseazƒÉ fi»ôierul Excel folosind datele din baza de date"""
        try:
            # Pas 1: CopiazƒÉ template-ul Excel
            print(f"üìã Copiez template-ul Excel...")
            success = copy_excel_file(template_path, output_path)

            if not success:
                print("‚ùå Eroare la copierea template-ului Excel")
                return False

            # Pas 2: Aici vor fi adƒÉugate func»õiile pentru popularea Excel-ului
            # cu date din baza de date
            print(f"üìä Populez Excel-ul cu date din baza de date...")

            # Exemplu simplu - po»õi extinde aceastƒÉ func»õie mai t√¢rziu
            # pentru a popula fi»ôierul Excel cu date din baza de date

            print(f"‚úÖ Excel procesat cu succes: {output_path}")
            return True

        except Exception as e:
            print(f"‚ùå Eroare la procesarea Excel-ului: {e}")
            return False

    def close_application(self):
        """√énchide aplica»õia »ôi »ôterge fi»ôierele temporare locale"""
        print("üîÑ √énchid aplica»õia...")

        # »òterge fi»ôierul temporar JSON
        if os.path.exists("beam_selection_temp.json"):
            try:
                os.remove("beam_selection_temp.json")
                print("üóëÔ∏è Fi»ôier temporar JSON »ôters")
            except Exception as e:
                print(f"‚ö†Ô∏è Nu am putut »ôterge fi»ôierul temporar JSON: {e}")

        # »òterge baza de date localƒÉ
        if os.path.exists("frames.db"):
            try:
                os.remove("frames.db")
                print("üóëÔ∏è Baza de date localƒÉ »ôtearsƒÉ")
            except Exception as e:
                print(f"‚ö†Ô∏è Nu am putut »ôterge baza de date localƒÉ: {e}")

        # Opre»ôte tracking
        if hasattr(self, 'beam_selection_active') and self.beam_selection_active:
            self.stop_beam_selection()

        print("üëã Aplica»õia se √Ænchide...")
        self.root.destroy()

    def unselect_all(self):
        """»òterge TOATE datele inclusiv baza de date localƒÉ"""
        print("üóëÔ∏è Clear All Selection - »ôterg toate datele...")

        # »òterge grupurile de grinzi
        self.all_beam_groups_a = []
        self.all_beam_groups_b = []
        self.current_beam_group = []

        # »òterge fi»ôierul temporar
        if os.path.exists("beam_selection_temp.json"):
            os.remove("beam_selection_temp.json")
            print("üóëÔ∏è Fi»ôier temporar »ôters")

        # »òterge fi»ôierul bazei de date locale
        if os.path.exists("frames.db"):
            os.remove("frames.db")
            print("üóëÔ∏è Baza de date localƒÉ »ôtearsƒÉ")

        # »òterge selec»õiile GUI
        self.clear_scenario_a()
        self.clear_scenario_b()

        # ReseteazƒÉ starea butoanelor
        for key in list(self.button_states.keys()):
            self.button_states[key] = False

        # ReseteazƒÉ alte stƒÉri
        self.rezistente_var.set("Normale")
        self.top_radio_state = "Normale"
        self.story_var.set("")
        self.etaj_value = None
        self.selected_combinations = {
            "A_upper": [], "A_lower": [], "B_upper": [], "B_lower": []
        }

        # »òterge selec»õia ETABS
        etabs_api.operations.clear_frame_selection()

        # ActualizeazƒÉ butoanele
        self.update_scenario_buttons("A")
        self.update_scenario_buttons("B")

        print("‚úÖ Toate datele au fost »ôterse. Gata pentru selec»õie nouƒÉ.")

    def check_selection(self):
        """Afi»ôeazƒÉ sumarul tuturor grinzilor selectate"""
        print("üìä Verificare date grinzi...")
        summary_data = self.get_detailed_summary_data()
        if summary_data and summary_data.get("scenarios"):
            SimpleSummaryPopup(self.root, summary_data)
        else:
            print("‚ùå Nu am date de grinzi pentru verificare")

    def start_beam_selection(self, scenario):
        """√éncepe procesul de selectare a grinzilor pentru scenariul dat"""
        if self.beam_selection_active:
            print("Selectarea grinzilor este deja activƒÉ!")
            return

        self.current_scenario = scenario
        self.beam_selection_active = True
        self.current_beam_group = []

        # »òterge orice selec»õie anterioarƒÉ √Æn ETABS
        etabs_api.operations.clear_frame_selection()

        print(f"√énceput selec»õie grinzi pentru {scenario}")
        print("Te rog selecteazƒÉ grinzi √Æn ETABS...")

        # Afi»ôeazƒÉ dialogul de confirmare
        self.show_selection_confirmation(scenario, is_first_group=True)

        # √éncepe urmƒÉrirea selec»õiilor de grinzi √Æn background
        self.start_tracking()

    def start_tracking(self):
        """√éncepe urmƒÉrirea selec»õiilor de grinzi"""
        if self.beam_selection_active:
            self.track_beam_selections()

    def track_beam_selections(self):
        """UrmƒÉre»ôte selec»õiile de grinzi √Æn ETABS √Æn timp real"""
        if not self.beam_selection_active:
            return

        try:
            # Ob»õine frame-urile selectate din ETABS (fƒÉrƒÉ limitƒÉ acum)
            selected_frames = etabs_api.operations.get_selected_frames_live()

            # ActualizeazƒÉ grupul curent cu toate frame-urile selectate
            self.current_beam_group = selected_frames.copy()

            if selected_frames:
                print(f"Grinzi selectate curent ({len(selected_frames)}): {selected_frames}")

            # ContinuƒÉ urmƒÉrirea
            self.tracking_id = self.root.after(500, self.track_beam_selections)

        except Exception as e:
            print(f"Eroare la urmƒÉrirea grinzilor: {e}")
            self.tracking_id = self.root.after(500, self.track_beam_selections)

    def stop_tracking(self):
        """Opre»ôte urmƒÉrirea selec»õiei grinzilor"""
        if self.tracking_id:
            self.root.after_cancel(self.tracking_id)
            self.tracking_id = None

    def stop_beam_selection(self):
        """Opre»ôte complet procesul de selectare a grinzilor"""
        self.beam_selection_active = False
        self.stop_tracking()
        print("Selectarea grinzilor opritƒÉ")

    def show_selection_confirmation(self, scenario, is_first_group=False):
        """Afi»ôeazƒÉ dialogul de confirmare pentru selec»õia grinzilor"""
        scenario_name = "Infrastructura" if scenario == "A" else "Suprastructura"

        self.confirmation_dialog = SelectionConfirmationDialog(
            parent=self.root,
            scenario_name=scenario_name,
            confirm_continue_callback=self.handle_confirm_continue,
            confirm_stop_callback=self.handle_confirm_stop,
            cancel_callback=self.handle_cancel,
            is_first_group=is_first_group
        )

    def handle_confirm_continue(self):
        """GestioneazƒÉ apƒÉsarea butonului 'ConfirmƒÉ »ôi continuƒÉ'"""
        print("ConfirmƒÉ »ôi continuƒÉ apƒÉsat")
        if self.confirm_and_continue():
            if self.confirmation_dialog:
                group_count = len(self.all_beam_groups_a if self.current_scenario == "A" else self.all_beam_groups_b)
                self.confirmation_dialog.update_message(
                    f"Grupul {group_count} confirmat!\n"
                    f"SelecteazƒÉ urmƒÉtorul grup de grinzi √Æn ETABS..."
                )
        else:
            if self.confirmation_dialog:
                self.confirmation_dialog.update_message(
                    "EROARE: Nici o grindƒÉ selectatƒÉ!\n"
                    "SelecteazƒÉ grinzi √Æn ETABS √Ænainte de confirmare."
                )

    def handle_confirm_stop(self):
        """GestioneazƒÉ apƒÉsarea butonului 'ConfirmƒÉ »ôi opre»ôte'"""
        print("ConfirmƒÉ »ôi opre»ôte apƒÉsat")
        if self.confirm_and_stop():
            if self.confirmation_dialog:
                self.confirmation_dialog.close_dialog()

    def handle_cancel(self):
        """GestioneazƒÉ apƒÉsarea butonului 'AnuleazƒÉ'"""
        print("AnuleazƒÉ apƒÉsat")
        if self.cancel_selection():
            if self.confirmation_dialog:
                self.confirmation_dialog.close_dialog()

    def confirm_and_continue(self):
        """ConfirmƒÉ grupul curent »ôi continuƒÉ cu urmƒÉtorul grup"""
        if self.current_beam_group:
            # SalveazƒÉ grupul curent √Æn scenariul corespunzƒÉtor
            if self.current_scenario == "A":
                self.all_beam_groups_a.append(self.current_beam_group.copy())
                current_groups = self.all_beam_groups_a
            else:
                self.all_beam_groups_b.append(self.current_beam_group.copy())
                current_groups = self.all_beam_groups_b

            print(
                f"Grupul {len(current_groups)} confirmat pentru scenariul {self.current_scenario}: {self.current_beam_group}")

            # SalveazƒÉ √Æn fi»ôier temporar
            self.save_temp_data(self.current_scenario, current_groups)

            # Ascunde grinzile
            success = etabs_api.operations.hide_specific_frames(self.current_beam_group)
            if success:
                print("Grinzi ascunse cu succes √Æn ETABS")
            else:
                print("Metoda de ascundere a e»ôuat")

            # »òterge selec»õia pentru urmƒÉtorul grup
            etabs_api.operations.clear_frame_selection()
            self.current_beam_group = []

            print("Gata pentru selec»õia urmƒÉtorului grup de grinzi...")
            return True
        else:
            print("Nu sunt grinzi selectate √Æn grupul curent!")
            return False

    def confirm_and_stop(self):
        """ConfirmƒÉ grupul curent »ôi opre»ôte selec»õia"""
        if self.current_beam_group:
            # SalveazƒÉ grupul curent
            if self.current_scenario == "A":
                self.all_beam_groups_a.append(self.current_beam_group.copy())
                current_groups = self.all_beam_groups_a
            else:
                self.all_beam_groups_b.append(self.current_beam_group.copy())
                current_groups = self.all_beam_groups_b

            print(f"Grupul final confirmat pentru scenariul {self.current_scenario}")

            # SalveazƒÉ √Æn fi»ôier temporar
            self.save_temp_data(self.current_scenario, current_groups)

            # Ascunde grinzile
            etabs_api.operations.hide_specific_frames(self.current_beam_group)

        # »òterge selec»õia »ôi opre»ôte
        etabs_api.operations.clear_frame_selection()
        self.stop_beam_selection()
        return True

    def cancel_selection(self):
        """AnuleazƒÉ selec»õia curentƒÉ fƒÉrƒÉ salvare"""
        print("Selec»õie anulatƒÉ")

        # »òterge selec»õia √Æn ETABS
        etabs_api.operations.clear_frame_selection()
        self.current_beam_group = []
        self.stop_beam_selection()
        return True

    def fill_listbox(self, listbox):
        """Umple listbox-ul dat cu combina»õii de proiectare"""
        for i in etabs_api.operations.get_comb_names():
            listbox.insert(tk.END, f"{i}")

    def set_variant(self, scenario, variant):
        """GestioneazƒÉ apƒÉsarea butoanelor de variantƒÉ"""
        scenario_obj = self.scenario_a if scenario == "A" else self.scenario_b
        buttons = scenario_obj.variant_buttons
        states = self.button_states

        if variant in ["DCL", "DCM", "DCH"]:
            # ApƒÉsarea DCL/DCM/DCH
            for v in ["DCL", "DCM", "DCH"]:
                pressed = (v == variant)
                buttons[v].config(relief="sunken" if pressed else "raised",
                                  background="lightblue" if pressed else "SystemButtonFace")
                states[(scenario, v)] = pressed
            # DeselecteazƒÉ Secundare automat
            buttons["Secundare"].config(relief="raised", background="SystemButtonFace")
            states[(scenario, "Secundare")] = False

        elif variant == "Secundare":
            # Secundare »ôterge DCL/DCM/DCH »ôi Dir X/Y
            for v in ["DCL", "DCM", "DCH", "Secundare"]:
                pressed = (v == "Secundare")
                buttons[v].config(relief="sunken" if pressed else "raised",
                                  background="lightblue" if pressed else "SystemButtonFace")
                states[(scenario, v)] = pressed
            # »òterge butoanele Dir
            for dir_btn in ["Dir X", "Dir Y"]:
                buttons[dir_btn].config(relief="raised", background="SystemButtonFace")
                states[(scenario, dir_btn)] = False

        else:  # Dir X / Dir Y
            other = "Dir X" if variant == "Dir Y" else "Dir Y"
            if states[(scenario, "Secundare")]:
                # »òterge butoanele Dir dacƒÉ Secundare este activ
                for dir_btn in ["Dir X", "Dir Y"]:
                    buttons[dir_btn].config(relief="raised", background="SystemButtonFace")
                    states[(scenario, dir_btn)] = False
            else:
                # ComutƒÉ butonul curent, asigurƒÉ-te cƒÉ doar un buton Dir este apƒÉsat
                buttons[variant].config(relief="sunken", background="lightgreen")
                buttons[other].config(relief="raised", background="SystemButtonFace")
                states[(scenario, variant)] = True
                states[(scenario, other)] = False

    def update_top_radio_state(self):
        """ActualizeazƒÉ starea radio butoanelor de sus"""
        self.top_radio_state = self.rezistente_var.get()

    def update_etaj_value(self, event=None):
        """ActualizeazƒÉ valoarea etajului c√¢nd se schimbƒÉ dropdown-ul"""
        self.etaj_value = self.story_var.get()
        print(f"Etaj selectat: {self.etaj_value}")

    def update_selected_combinations(self):
        """ActualizeazƒÉ combina»õiile selectate din listbox-uri"""
        self.selected_combinations["A_upper"] = [self.scenario_a.list_upper.get(i) for i in
                                                 self.scenario_a.list_upper.curselection()]
        self.selected_combinations["A_lower"] = [self.scenario_a.list_lower.get(i) for i in
                                                 self.scenario_a.list_lower.curselection()]
        self.selected_combinations["B_upper"] = [self.scenario_b.list_upper.get(i) for i in
                                                 self.scenario_b.list_upper.curselection()]
        self.selected_combinations["B_lower"] = [self.scenario_b.list_lower.get(i) for i in
                                                 self.scenario_b.list_lower.curselection()]

    def get_current_state(self):
        """ReturneazƒÉ un snapshot complet al tuturor stƒÉrilor"""
        self.update_top_radio_state()
        self.update_selected_combinations()
        return {
            "button_states": self.button_states.copy(),
            "top_radio_state": self.top_radio_state,
            "selected_combinations": self.selected_combinations.copy(),
            "etaj": self.etaj_value,
            "beam_groups_a": self.all_beam_groups_a.copy(),
            "beam_groups_b": self.all_beam_groups_b.copy()
        }

    def clear_scenario_a(self):
        """DeselecteazƒÉ doar selec»õiile scenariului A"""
        self.scenario_a.list_upper.selection_clear(0, tk.END)
        self.scenario_a.list_lower.selection_clear(0, tk.END)
        self.update_selected_combinations()

    def clear_scenario_b(self):
        """DeselecteazƒÉ doar selec»õiile scenariului B"""
        self.scenario_b.list_upper.selection_clear(0, tk.END)
        self.scenario_b.list_lower.selection_clear(0, tk.END)
        self.update_selected_combinations()

    def update_scenario_buttons(self, scenario):
        """ActualizeazƒÉ aspectul butoanelor pentru un scenariu"""
        scenario_obj = self.scenario_a if scenario == "A" else self.scenario_b
        buttons = scenario_obj.variant_buttons

        for variant, btn in buttons.items():
            state = self.button_states.get((scenario, variant), False)
            if variant in ["DCL", "DCM", "DCH", "Secundare"]:
                btn.config(relief="sunken" if state else "raised",
                           background="lightblue" if state else "SystemButtonFace")
            else:  # Dir X / Dir Y
                btn.config(relief="sunken" if state else "raised",
                           background="lightgreen" if state else "SystemButtonFace")

    def browse_default_file(self):
        """Deschide dialogul pentru selectarea fi»ôierului default"""
        filename = filedialog.askopenfilename(title="SelecteazƒÉ fi»ôierul default",
                                              filetypes=[("Fi»ôiere Excel", "*.xlsx"), ("Toate fi»ôierele", "*.*")])
        if filename:
            self.file_frame.default_file_var.set(filename)

    def browse_result_folder(self):
        """Deschide dialogul pentru selectarea folderului de rezultate"""
        folder = filedialog.askdirectory(title="SelecteazƒÉ folderul de rezultate")
        if folder:
            self.file_frame.result_folder_var.set(folder)

    def save_temp_data(self, scenario, beam_groups):
        """SalveazƒÉ datele temporare pentru un scenariu"""
        data = {
            "timestamp": datetime.now().isoformat(),
            f"scenario_{scenario.lower()}": {
                "beam_groups": beam_groups,
                "rezistente_type": self.top_radio_state,
                "etaj": self.etaj_value,
                "selected_combinations_upper": self.selected_combinations[f"{scenario}_upper"],
                "selected_combinations_lower": self.selected_combinations[f"{scenario}_lower"],
                "button_states": {k[1]: v for k, v in self.button_states.items() if k[0] == scenario}
            }
        }

        with open("beam_selection_temp.json", 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        print(f"üíæ Date salvate pentru scenariul {scenario}")

    def get_detailed_summary_data(self):
        """ReturneazƒÉ datele detaliate pentru verificare"""
        summary = {
            "timestamp": datetime.now().isoformat(),
            "scenarios": {}
        }

        # ProceseazƒÉ scenariul A
        if self.all_beam_groups_a:
            summary["scenarios"]["Infrastructura"] = {
                "group_count": len(self.all_beam_groups_a),
                "total_beams": sum(len(group) for group in self.all_beam_groups_a),
                "beam_groups": [],
                "settings": {
                    "rezistente_type": self.top_radio_state,
                    "etaj": self.etaj_value,
                    "combinations_upper": self.selected_combinations["A_upper"],
                    "combinations_lower": self.selected_combinations["A_lower"],
                    "button_states": {k[1]: v for k, v in self.button_states.items() if k[0] == "A"}
                }
            }

            for group_idx, group in enumerate(self.all_beam_groups_a, 1):
                group_info = {
                    "group_number": group_idx,
                    "beams": []
                }
                for beam_name in group:
                    beam_info = self.get_beam_info(beam_name)
                    group_info["beams"].append({
                        "unique_name": beam_name,
                        "label": beam_info["Label"],
                        "story": beam_info["Story"],
                        "length": beam_info["Length"],
                        "section_name": beam_info["SectionName"],
                        "material": beam_info["Material"]
                    })
                summary["scenarios"]["Infrastructura"]["beam_groups"].append(group_info)

        # ProceseazƒÉ scenariul B
        if self.all_beam_groups_b:
            summary["scenarios"]["Suprastructura"] = {
                "group_count": len(self.all_beam_groups_b),
                "total_beams": sum(len(group) for group in self.all_beam_groups_b),
                "beam_groups": [],
                "settings": {
                    "rezistente_type": self.top_radio_state,
                    "etaj": self.etaj_value,
                    "combinations_upper": self.selected_combinations["B_upper"],
                    "combinations_lower": self.selected_combinations["B_lower"],
                    "button_states": {k[1]: v for k, v in self.button_states.items() if k[0] == "B"}
                }
            }

            for group_idx, group in enumerate(self.all_beam_groups_b, 1):
                group_info = {
                    "group_number": group_idx,
                    "beams": []
                }
                for beam_name in group:
                    beam_info = self.get_beam_info(beam_name)
                    group_info["beams"].append({
                        "unique_name": beam_name,
                        "label": beam_info["Label"],
                        "story": beam_info["Story"],
                        "length": beam_info["Length"],
                        "section_name": beam_info["SectionName"],
                        "material": beam_info["Material"]
                    })
                summary["scenarios"]["Suprastructura"]["beam_groups"].append(group_info)

        return summary

    def get_beam_info(self, beam_name):
        """Extrage informa»õii despre o grindƒÉ din ETABS"""
        try:
            label, story = etabs_api.operations.get_label_and_story(beam_name)
            guid = etabs_api.operations.get_frame_guid(beam_name)
            section_name = etabs_api.operations.get_section_name(beam_name)

            return {
                "UniqueName": beam_name,
                "Label": label,
                "Story": story,
                "GUID": guid,
                "SectionName": section_name,
                "Length": 0,  # Po»õi adƒÉuga lungimea dacƒÉ este necesar
                "Material": "Concrete"
            }
        except Exception as e:
            print(f"Eroare la ob»õinerea informa»õiilor pentru {beam_name}: {e}")
            return {
                "UniqueName": beam_name,
                "Label": "N/A",
                "Story": "N/A",
                "GUID": "N/A",
                "SectionName": "N/A",
                "Length": 0,
                "Material": "Concrete"
            }

    def run(self):
        """RuleazƒÉ aplica»õia principalƒÉ"""
        self.root.mainloop()


if __name__ == "__main__":
    app = DesignApp()
    app.run()